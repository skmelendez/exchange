using Godot;
using Exchange.Core;

namespace Exchange.Map;

/// <summary>
/// Contains all nodes and connections for a single act.
/// Generated by MapGenerator using STS-style branching path algorithm.
/// Players navigate left-to-right through nodes until reaching the boss.
/// </summary>
public class ActMap
{
    /// <summary>Which act this map represents (1-4, where 4 is Final Boss).</summary>
    public int ActNumber { get; }

    /// <summary>Configuration parameters used to generate this map.</summary>
    public ActConfig Config { get; }

    /// <summary>All nodes in this act map.</summary>
    public List<MapNode> Nodes { get; } = [];

    /// <summary>Seed used for deterministic generation (for save/load).</summary>
    public int Seed { get; }

    /// <summary>Nodes at column 0 where player can begin.</summary>
    public List<MapNode> StartingNodes { get; } = [];

    /// <summary>The boss node at the final column (all paths converge here).</summary>
    public MapNode? BossNode { get; private set; }

    /// <summary>The node the player is currently at (null if selecting start).</summary>
    public MapNode? CurrentNode { get; private set; }

    /// <summary>Grid for O(1) position-based node lookup [column, row].</summary>
    private readonly MapNode?[,] _grid;

    /// <summary>
    /// Creates a new act map with the given configuration.
    /// </summary>
    /// <param name="config">Act generation parameters</param>
    /// <param name="seed">Random seed for deterministic generation</param>
    public ActMap(ActConfig config, int seed)
    {
        ActNumber = config.ActNumber;
        Config = config;
        Seed = seed;
        _grid = new MapNode?[config.Columns, config.MaxRows];
    }

    /// <summary>
    /// Adds a node to the map and updates grid/tracking collections.
    /// </summary>
    /// <param name="node">The node to add</param>
    public void AddNode(MapNode node)
    {
        Nodes.Add(node);

        // Add to grid
        if (node.Position.Column < Config.Columns && node.Position.Row < Config.MaxRows)
        {
            _grid[node.Position.Column, node.Position.Row] = node;
        }

        // Track special nodes
        if (node.Position.Column == 0)
        {
            StartingNodes.Add(node);
        }
        else if (node.NodeType == MapNodeType.Boss)
        {
            BossNode = node;
        }
    }

    public MapNode? GetNodeAt(int column, int row)
    {
        if (column < 0 || column >= Config.Columns || row < 0 || row >= Config.MaxRows)
            return null;
        return _grid[column, row];
    }

    public MapNode? GetNodeAt(MapPosition pos) => GetNodeAt(pos.Column, pos.Row);

    public MapNode? GetNodeById(int id) => Nodes.FirstOrDefault(n => n.Id == id);

    /// <summary>
    /// Connect two nodes (source -> target)
    /// </summary>
    public void Connect(MapNode source, MapNode target)
    {
        if (!source.OutgoingConnections.Contains(target.Id))
            source.OutgoingConnections.Add(target.Id);

        if (!target.IncomingConnections.Contains(source.Id))
            target.IncomingConnections.Add(source.Id);
    }

    /// <summary>
    /// Set the current node and update accessibility
    /// </summary>
    public void SetCurrentNode(MapNode? node)
    {
        // Clear previous
        if (CurrentNode != null)
        {
            CurrentNode.IsCurrentNode = false;
        }

        CurrentNode = node;

        // Update accessibility - only nodes connected from current are accessible
        foreach (var n in Nodes)
        {
            n.IsAccessible = false;
        }

        if (node != null)
        {
            node.IsCurrentNode = true;
            node.IsVisited = true;

            GameLogger.Debug("ActMap", $"SetCurrentNode: {node.NodeType} at {node.Position}, outgoing: {node.OutgoingConnections.Count}");

            // Nodes we can move to
            foreach (var targetId in node.OutgoingConnections)
            {
                var target = GetNodeById(targetId);
                if (target != null)
                {
                    target.IsAccessible = true;
                    GameLogger.Debug("ActMap", $"  -> Made accessible: {target.NodeType} at {target.Position} (ID: {target.Id})");
                }
            }
        }
        else
        {
            // No current node means we're at start - starting nodes are accessible
            GameLogger.Debug("ActMap", $"SetCurrentNode: null - {StartingNodes.Count} starting nodes accessible");
            foreach (var start in StartingNodes)
            {
                start.IsAccessible = true;
            }
        }
    }

    /// <summary>
    /// Get all nodes the player can currently move to
    /// </summary>
    public List<MapNode> GetAccessibleNodes() =>
        Nodes.Where(n => n.IsAccessible).ToList();

    /// <summary>
    /// Debug print the map structure
    /// </summary>
    public void DebugPrint()
    {
        GD.Print($"\n=== Act {ActNumber} Map (Seed: {Seed}) ===");
        GD.Print($"Nodes: {Nodes.Count}, Starting: {StartingNodes.Count}");

        for (int col = 0; col < Config.Columns; col++)
        {
            GD.Print($"\nColumn {col}:");
            for (int row = 0; row < Config.MaxRows; row++)
            {
                var node = GetNodeAt(col, row);
                if (node != null)
                {
                    var outgoing = string.Join(", ", node.OutgoingConnections.Select(id =>
                    {
                        var target = GetNodeById(id);
                        return target != null ? $"{target.Position}" : "?";
                    }));
                    GD.Print($"  [{row}] {node.NodeType,-8} -> {outgoing}");
                }
            }
        }
        GD.Print("");
    }
}
